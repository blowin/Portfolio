<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>programming on Сущевский Дмитрий</title><link>https://blowin.github.io/portfolio/categories/programming/</link><description>Recent content in programming on Сущевский Дмитрий</description><generator>Hugo -- gohugo.io</generator><language>ru</language><lastBuildDate>Mon, 12 Sep 2022 07:09:06 +0300</lastBuildDate><atom:link href="https://blowin.github.io/portfolio/categories/programming/index.xml" rel="self" type="application/rss+xml"/><item><title>Умная ути-ути-утилизация</title><link>https://blowin.github.io/portfolio/posts/2022/09/%D1%83%D0%BC%D0%BD%D0%B0%D1%8F-%D1%83%D1%82%D0%B8-%D1%83%D1%82%D0%B8-%D1%83%D1%82%D0%B8%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F/</link><pubDate>Mon, 12 Sep 2022 07:09:06 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/09/%D1%83%D0%BC%D0%BD%D0%B0%D1%8F-%D1%83%D1%82%D0%B8-%D1%83%D1%82%D0%B8-%D1%83%D1%82%D0%B8%D0%BB%D0%B8%D0%B7%D0%B0%D1%86%D0%B8%D1%8F/</guid><description>После очистки нашей истории от лжи не обязательно должна остаться только правда, порой вообще ничего не остается.
Станислав Ежи Лец
Введение Сегодня поговорим об управлении ресурами, а именно о методе Dispose и библиотеке Lifetime от Jetbrains, которая помогает управлять утилизацией ресурсов.
IDisposable - Интерфейс, который предоставляет собой механизм для освобождения неуправляемых ресурсов (согласно MSDN).
Очень простое определение, за которым скрывается большое количество нюансов, но об этом далее.
Проблема Так что же не так с интерфейсом IDisposable?</description></item><item><title>Оценка сложности кода</title><link>https://blowin.github.io/portfolio/posts/2022/09/%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B0-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BA%D0%BE%D0%B4%D0%B0/</link><pubDate>Fri, 09 Sep 2022 17:10:31 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/09/%D0%BE%D1%86%D0%B5%D0%BD%D0%BA%D0%B0-%D1%81%D0%BB%D0%BE%D0%B6%D0%BD%D0%BE%D1%81%D1%82%D0%B8-%D0%BA%D0%BE%D0%B4%D0%B0/</guid><description>Упрощенчество — непонимание сложностей.
Простота — способность разрешать сложности.
Эрик-Эмманюэль Шмитт
Введение Сегодня хотелось бы обсудить сложность кода и один из способов объективного подсчёта сложности. Мы не будем считать количество строк в метода, хотя этот параметр явно не стоит упускать из виду. Сегодня мы поговорим о Cognitive complexity
Проблема Как вы понимаете, что один фрагмент кода является простым и более понятным, чем другой? Есть ли у вас чёткие критерии, по которым вы можете однозначно сказать какой из фрагментов кода проще?</description></item><item><title>Markdown is king</title><link>https://blowin.github.io/portfolio/posts/2022/08/markdown-is-king/</link><pubDate>Mon, 15 Aug 2022 20:18:05 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/08/markdown-is-king/</guid><description>Наводить порядок надо тогда, когда еще нет смуты.
Лао-Цзы
Введение Markdown — облегчённый язык разметки, созданный с целью обозначения форматирования в простом тексте, с максимальным сохранением его читаемости человеком и пригодный для машинного преобразования в языки для продвинутых публикаций (HTML, Rich Text и других). (источник - Wiki)
Сегодня Markdown является стандартом дефакто для ведения GitHub (файлы README.md) документации и всё больше проникает в нашу повсеместную жизнь.
Для чего ещё используют Markdown:</description></item><item><title>Начинаем действовать</title><link>https://blowin.github.io/portfolio/posts/2022/07/%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D0%B5%D0%BC-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D1%82%D1%8C/</link><pubDate>Wed, 13 Jul 2022 07:56:10 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/07/%D0%BD%D0%B0%D1%87%D0%B8%D0%BD%D0%B0%D0%B5%D0%BC-%D0%B4%D0%B5%D0%B9%D1%81%D1%82%D0%B2%D0%BE%D0%B2%D0%B0%D1%82%D1%8C/</guid><description>Меня не пугают никакие действия, куда страшнее бездействие.
Майкл Скофилд
Введение Поговорим про GitHub Actions, этот механизм позволяет выполнять огромное количество работы, включая CI/CD.
CI/CD - это комбинация непрерывной интеграции (continuous integration) и непрерывного развертывания (continuous delivery или continuous deployment) программного обеспечения в процессе разработки. CI/CD объединяет разработку, тестирования и развёртывания приложения.(источник - Wiki)
Разберём, как можно настроить сборку и запуск тестов для .NET проекта, с использованием GitHub Actions.</description></item><item><title>Как правильно быть одиноким?</title><link>https://blowin.github.io/portfolio/posts/2022/07/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B1%D1%8B%D1%82%D1%8C-%D0%BE%D0%B4%D0%B8%D0%BD%D0%BE%D0%BA%D0%B8%D0%BC/</link><pubDate>Thu, 07 Jul 2022 08:28:55 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/07/%D0%BA%D0%B0%D0%BA-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE-%D0%B1%D1%8B%D1%82%D1%8C-%D0%BE%D0%B4%D0%B8%D0%BD%D0%BE%D0%BA%D0%B8%D0%BC/</guid><description>Мне было одиноко, но удобно.
Дэниел Фордж
Введение Сегодня будем говорить про Singleton и то как стоит его использовать.
Одиночка (англ. Singleton) — порождающий шаблон проектирования, гарантирующий, что в однопоточном приложении будет единственный экземпляр некоторого класса, и предоставляющий глобальную точку доступа к этому экземпляру. (источник - Wiki)
В качестве примера будем использовать следующую сущность.
public record Status(Guid Id, string Name); Проблема Приходилось ли вам видеть код подобного рода?</description></item><item><title>Объективная значимость</title><link>https://blowin.github.io/portfolio/posts/2022/06/%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F-%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C/</link><pubDate>Wed, 22 Jun 2022 12:15:01 +0400</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/06/%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%B8%D0%B2%D0%BD%D0%B0%D1%8F-%D0%B7%D0%BD%D0%B0%D1%87%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D1%8C/</guid><description>Вот так и впадают в заблуждение — уменьшая значимость важных вещей.
Настоящий детектив
Введение Сегодня поговорим о таком понятии как &amp;lsquo;Value Object&amp;rsquo;. VO часто используется в Domain Driven Design (DDD).
Value Object - это небольшой объект, представляющий простую сущность, равенство которой не основано на идентичности: т.е. два объекта значений равны, когда они имеют одинаковое значение, не обязательно являясь одним и тем же объектом. (Далее VO)
Отличительные черты VO:</description></item><item><title>Хорошие подделки</title><link>https://blowin.github.io/portfolio/posts/2022/06/%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B8/</link><pubDate>Thu, 16 Jun 2022 11:10:07 +0400</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/06/%D1%85%D0%BE%D1%80%D0%BE%D1%88%D0%B8%D0%B5-%D0%BF%D0%BE%D0%B4%D0%B4%D0%B5%D0%BB%D0%BA%D0%B8/</guid><description>Отвратительней поддельных цветов может быть лишь поддельное оружие.
Вера Камша
Введение Мне часто приходится генерировать тестовые данные, либо для тестов, либо во время работы для заполнения базы данных. Такая работа является рутинной, к тому же тяжело руками сгенерировать правдоподобные и не повторяющиеся данные, которые были бы осмысленными.
Огромный пласт моих проблем ушел, когда я открыл для себя Bogus, это библиотека для генерирования правдоподобных фейковых данных, которые можно использовать в тестах, для инициализации базы данных или в любом другом месте, где нужны какие-то фейковые данные.</description></item><item><title>Слишком глубокий смысл</title><link>https://blowin.github.io/portfolio/posts/2022/06/%D1%81%D0%BB%D0%B8%D1%88%D0%BA%D0%BE%D0%BC-%D0%B3%D0%BB%D1%83%D0%B1%D0%BE%D0%BA%D0%B8%D0%B9-%D1%81%D0%BC%D1%8B%D1%81%D0%BB/</link><pubDate>Wed, 08 Jun 2022 17:52:47 +0400</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/06/%D1%81%D0%BB%D0%B8%D1%88%D0%BA%D0%BE%D0%BC-%D0%B3%D0%BB%D1%83%D0%B1%D0%BE%D0%BA%D0%B8%D0%B9-%D1%81%D0%BC%D1%8B%D1%81%D0%BB/</guid><description>Мужество — лучшее смертоносное оружие: мужество убивает даже сострадание. Сострадание же есть наиболее глубокая пропасть: ибо, насколько глубоко человек заглядывает в жизнь, настолько глубоко заглядывает он и в страдание.
Фридрих Вильгельм Ницше
Проблема Обращали ли вы внимание, как тяжело читать код с большой вложенностью? Думаю, что да. Такой код очень тяжел в понимании и поддержании из-за чего подвержен большему количеству ошибок. В этой статье рассмотрим способы решения данной проблемы и посмотрим как меняется код в лучшую сторону, при соблюдении простых правил.</description></item><item><title>Electron + Blazor = ♥</title><link>https://blowin.github.io/portfolio/posts/2022/05/electron--blazor/</link><pubDate>Fri, 20 May 2022 17:15:40 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/05/electron--blazor/</guid><description>Опишу, как можно собрать blazor проект с использованием electron. Это можно использовать, для любого ASP проекта.
Шаги Устанавливаем electronNet.cli (один раз) dotnet tool install --global electronNet.cli Установить nuget пакет ElectronNET.API Добавить в Startup создание окна if (HybridSupport.IsElectronActive) { Task.Run(async () =&amp;gt; { await Electron.WindowManager.CreateBrowserViewAsync(); await Electron.WindowManager.CreateWindowAsync(new BrowserWindowOptions { MinWidth = 700, MinHeight = 500, Center = true }); }); } Добавить UseElectron в Program.</description></item><item><title>Примитивизм</title><link>https://blowin.github.io/portfolio/posts/2022/05/%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%B8%D0%B7%D0%BC/</link><pubDate>Thu, 12 May 2022 20:21:29 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/05/%D0%BF%D1%80%D0%B8%D0%BC%D0%B8%D1%82%D0%B8%D0%B2%D0%B8%D0%B7%D0%BC/</guid><description>На протяжении всего своего пути в программировании я сталкиваюсь с проблемой повсеместного использования примитивных типов, они повсюду.
Хотя мы и имитируем реальный мир, но мы раз за разом используем примитивные типы, для всего многообразия понятий, которые мы моделируем в коде. Эти понятия имеют больше ограничений, чем тип, который мы используем. Чтобы решить эту проблему, существует такое понятие как Value Object, оно отображает конкретное понятие с инкапсулированной логикой.
Что не так с примитивами?</description></item><item><title>Конструируй правильно</title><link>https://blowin.github.io/portfolio/posts/2022/05/%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%B8%D1%80%D1%83%D0%B9-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE/</link><pubDate>Wed, 11 May 2022 17:29:30 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/05/%D0%BA%D0%BE%D0%BD%D1%81%D1%82%D1%80%D1%83%D0%B8%D1%80%D1%83%D0%B9-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D1%8C%D0%BD%D0%BE/</guid><description>Конструктор - это точка входа в любой объект. Это метод, который служит инициализатором вашего типа, проверяет инварианты, переводит объект в состояние пригодное для использования.
Каждый день мы пишем свои типы, они в дальнейшем будут использовать и наши коллеги. Но сталкивались ли вы с тем, что после создания объекта вы получали ошибки связанные с тем, что после создания объекта какие-то из полей не были проинициализированы? Если не встречали, то вам очень повезло, к сожалению, я не из таких людей.</description></item><item><title>Анатомия декоратора</title><link>https://blowin.github.io/portfolio/posts/2022/05/%D0%B0%D0%BD%D0%B0%D1%82%D0%BE%D0%BC%D0%B8%D1%8F-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0/</link><pubDate>Thu, 05 May 2022 20:30:50 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/05/%D0%B0%D0%BD%D0%B0%D1%82%D0%BE%D0%BC%D0%B8%D1%8F-%D0%B4%D0%B5%D0%BA%D0%BE%D1%80%D0%B0%D1%82%D0%BE%D1%80%D0%B0/</guid><description>Как известно, декоратор является одним из структурных паттернов проектирования. Его удобно комбинировать с другими паттернами для достижения гибкой и расширяемой системы, без изменения существующего кода.
Разбираемся на примере логирования Допустим, перед нами появилась задача написать логирование для нашего приложения. Что же, давайте реализуем:
public enum LogLevel { Debug, Info, Warn, Error, Fatal } public interface ILogger : IDisposable { void Log(LogLevel level, string message, params object[] args); } public class ConsoleLogger : ILogger { public void Log(LogLevel level, string message, params object[] args) { Console.</description></item><item><title>Дружелюбная Factory</title><link>https://blowin.github.io/portfolio/posts/2022/05/%D0%B4%D1%80%D1%83%D0%B6%D0%B5%D0%BB%D1%8E%D0%B1%D0%BD%D0%B0%D1%8F-factory/</link><pubDate>Sun, 01 May 2022 19:46:31 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/05/%D0%B4%D1%80%D1%83%D0%B6%D0%B5%D0%BB%D1%8E%D0%B1%D0%BD%D0%B0%D1%8F-factory/</guid><description>Сталкивались ли вы с проблемой, когда у вас есть factory, вы её создаёте там, где вам нужен определенный тип объекта и вы знаете, что нет необходимости передавать все зависимости в конструктор factory, так как они просто не нужны для создания. Тогда вы передаёте default/null?
Как правило, выглядит так себе:
var factory = new ObjFactory(null, docId, dbService, null, null); var doc = factory.Create(ObjType.Doc); У данного подхода я не вижу плюсов от слова &amp;lsquo;совсем&amp;rsquo;.</description></item><item><title>Enum и switch, сквозь года</title><link>https://blowin.github.io/portfolio/posts/2022/04/enum-%D0%B8-switch-%D1%81%D0%BA%D0%B2%D0%BE%D0%B7%D1%8C-%D0%B3%D0%BE%D0%B4%D0%B0/</link><pubDate>Fri, 29 Apr 2022 19:16:46 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2022/04/enum-%D0%B8-switch-%D1%81%D0%BA%D0%B2%D0%BE%D0%B7%D1%8C-%D0%B3%D0%BE%D0%B4%D0%B0/</guid><description>Пару лет назад я написал о Enum и switch и что с ним не так. По прошествии нескольких лет, произошли определенные переосмысления, которые выросли в данную статью.
Проблема Проблема остаётся той же:
огромные switch по всему коду проблемы с поддержкой этого добра. Что использовать для решения проблемы Будем использовать библиотеку SmartEnum.
На самом деле подобный функционал реализуется за 15 минут, если по каким-то причинам вы не хотите тянуть лишнюю зависимость в ваше детище ваш проект.</description></item><item><title>Enum и switch, и что с ними не так</title><link>https://blowin.github.io/portfolio/posts/2020/09/enum-%D0%B8-switch-%D0%B8-%D1%87%D1%82%D0%BE-%D1%81-%D0%BD%D0%B8%D0%BC%D0%B8-%D0%BD%D0%B5-%D1%82%D0%B0%D0%BA/</link><pubDate>Fri, 04 Sep 2020 14:00:00 +0300</pubDate><guid>https://blowin.github.io/portfolio/posts/2020/09/enum-%D0%B8-switch-%D0%B8-%D1%87%D1%82%D0%BE-%D1%81-%D0%BD%D0%B8%D0%BC%D0%B8-%D0%BD%D0%B5-%D1%82%D0%B0%D0%BA/</guid><description>Часто ли у вас было такое, что вы добавляли новое значение в enum и потом тратили часы на то, чтобы найти все места его использования, а затем добавить новый case, чтобы не получить ArgumentOutOfRangeException во время исполнения?
Идея Если проблема состоит только в switch операторе и отслеживании новых типов, тогда давайте избавимся от них!
Идея состоит в том, чтобы заменить использование switch паттерном visitor.
Пример 1 Предположим у нас есть какой-то API для работы с документами, от которого мы получаем необходимые данные и определяем его тип, а далее в зависимости от этого типа, необходимо делать различные операции.</description></item></channel></rss>